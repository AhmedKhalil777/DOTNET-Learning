# In The Name OF ALLAH
---
- ## __HTML Form and Basic Model Binding__
---

- Let's assume that we host our ASP.NET Core web application at http://localhost:5000.
- The user gets the HTML form below by accessing our web application:
```
<form action="film/create" method="GET">
    <label for="name">Name</label>
    <input type="text" name="name" value="Transformer" /><br/>
    <label for="year">Year</label>
    <input type="text" name="year" value="2017" /><br/>
    <input type="submit" name="submit" value="Create" />
</form>
```
- When the user clicks the “Create” button, these things happen:

- The information contained in the HTML form will be sent back to the web application running at http://localhost:5000.

- Each __\<input/>__ tag will generate a name-value pair.
  - The __name attribute__ and the __value attribute__ provide the name part and the value part of the name-value pair respectively.

- The code __action="film/create"__ indicates the destination to where the data will be sent.
-  The ASP.NET Core web application will __parse the string film/create__ to a method of the __controller class__.
- The process of parsing the action string and finding the method is called __URL routing__, and the destination method is called an __action__.

- Without exceptions, the string __action="film/create"__ will route the data to the Create action method of the __FilmController__ class.

- The code __method="GET"__ asks the web browser to weave the name-value pairs into the URL.
- Thus the user will see the URL __http://localhost:5000/film/create?name=Transformer&year=2017&submit=Create__ in the address bar of the web browser.
- You may have noticed, even the name-value pair generated by the submit button is woven in the URL, then you can use this name-value pair to determine what to do with the data.

- Now let's take a glance at the model binding of ASP.NET Core.
-  Please remember, all values sent back to the web application through the HTTP request are string type values.
- For example, in the name-value pair year=2017, the 2017 is actually a string.
- But when we design the action method for processing these values, the method signature could be:
```
public IActionResult Create(string name, int year) {
    // logic ...
}
```
- The basic ideas here are:

- The model binding is not case-sensitive.
- So the parameter name can be name or Name, year or Year.
- We use name and year because the camel casing is the name convention for C# method parameters.
- The model binding will help us do some simple type conversion.
- This is why we can declare the parameter year as an int type.
-  What about if the user inputs a year value which is not a valid integer?
- The URL routing will try to find another Create action method whose parameters match to the form data, if it's not found, the ASP.NET Core framework will send a 404 Not Found HTTP response to the web browser.

- We can ignore some form data items if we don't need them.

- In this case, we just ignored the submit=Create name-value pair.
---

## Advanced Model Binding
---
- To weave the form data into a URL is not always a good idea.

- Sometimes, perhaps for security reasons, you may not want the user to see the values.
- Sometimes it is just because the data structure is too complicated to be carried by the URL string.
- For example, you have an array of data.
- In these cases, we should set the method attribute of the HTML form to be POST and also design a proper data transfer model class to accept the complex data from the form.

- > Let's take a look at the form element below:

```
<form action="createorupdate" method="POST">
    <span>ID</span>
    <input type="text" name="id" value="101" /><br />
    <span>Name</span>
    <input type="text" name="name" value="Transformer" /><br/>
    <span>Year</span>
    <select name="year">
        <option value="2015">2015</option>
        <option value="2016">2016</option>    
        <option value="2017">2017</option>    
    </select><br/>
    <span>Genre</span>
    <input type="checkbox" name="genres" value="action" /><span>Action</span>
    <input type="checkbox" name="genres" value="comedy" /><span>Comedy</span>
    <input type="checkbox" name="genres" value="war" /><span>War</span><br/>
    <span>In Store</span>
    <input type="radio" name="isinstore" value="true" /><span>Yes</span>
    <input type="radio" name="isinstore" value="false" /><span>No</span><br/>
    <input type="submit" name="operation" value="Create" />
    <input type="submit" name="operation" value="Update" />
</form>
```
- From the attribute __action="film/CreateOrUpdate"__ we know that there should be an action method called CreateOrUpdate to process the data sent by this form.

- We rarely combine multiple operations in a single form but this form is an exception, that's because we want to use it to demonstrate how to design the data transfer model.

- As the method attribute is set to be POST, when the user clicks one of the submit buttons, the name-value pairs generated from input elements will be encapsulated in the form data block of the HTTP request.
- That means the user won't see the name-value pairs in the address bar.

- To design the data transfer model, you need to find all elements where the name attribute is set.
- Please note, only the name attribute is for name-value pair generation, the id attribute is for the CSS engine and JavaScript engine of the web browser to index/find the elements.

- Usually, the name-value pairs are unique, like the hidden input for the film ID and the text box input for the film name.
- For these types of elements, we should create non-collection type properties in the data transfer model class.

- But sometimes multiple values may share the same name, or multiple elements may have the same name.
- Based on whether multiple values can be selected, we may create collection type properties or non-collection type properties for them.
- In this example, the select element for the year of the film is a single value dropdown list.
-  The radio button group allows only one value to be checked, and only one submit button has a chance to be clicked.
- So we should create non-collection type properties for them.
- While the checkbox group for film genres is multi-selectable, we have to create collection type property for it.

- Based on the information we collect from the __\<form>__ element, our data transfer model for this form may look like:
```
public class CreateOrUpdateDTO {
    public int ID { get; set; }
    public string Name { get; set; }
    public int Year { get; set; }
    public Genre[] Genres { get; set; }
    public bool IsInStore { get; set; }
    public Operation Operation { get; set; }
}
```
```
public enum Genre {
    Action,
    Comedy,
    War,
    // ...
}
```
```
public enum Operation {
    Create,
    Update,
    // ...
}
```
- When the HTTP request is routed to the destination action method, the model binding engine will extract the data from the form data block of the HTTP request and cast these name-value pairs to an instance of the DTO type.
-  Thus the signature of the action method will look like:
```
public IActionResult CreateOrUpdate(CreateOrUpdateDTO dto) {
    if (dto.Operation == Operation.Create) {
        // create a new film
    } else if (dto.Operation == Operation.Update) {
        // update the existing film by ID
    } else {
        // ...
    }
}
```
---
## __Domain Model as DTO__
---
- In a real-world project, we rarely use a single form for both creating and updating operations.
- If we separate the creating and updating of the previous form, we will get two forms as below:
```
<form action="film/create" method="POST">
    <span>Name</span>
    <input type="text" name="name" value="Transformer" /><br/>
    <!--other elements-->
    <input type="submit" value="Create" />
</form>
```
- and:
```
<form action="film/update" method="POST">
    <input type="hidden" name="id" value="101" />
    <span>Name</span>
    <input type="text" name="name" value="Transformer" /><br/>
    <!--other elements-->
    <input type="submit" value="Update" />
</form>
```
- After the separation, we no longer need the type enum Operation and property public Operation Operation { get; set; }. So the DTO class simplifies to:
```
public class CreateOrUpdateDTO {
    public int ID { get; set; }
    public string Name { get; set; }
    public int Year { get; set; }
    public ICollection<Genre> Genres { get; set; }
    public bool IsInStore { get; set; }
}
```
- It's easy to notice that the DTO class is as same as the Film domain model class:
```
public class Film {
    public int ID { get; set; }
    public string Name { get; set; }
    public int Year { get; set; }
    public ICollection<Genre> Genres { get; set; }
    public bool IsInStore { get; set; }
}
```
- In this situation, we don't need to create the class CreateOrUpdateDTO at all.
- We use the Film domain as the DTO class directly.\
- Accordingly, the two action methods will look like:
```
public IActionResult Create(Film film) {
    // create a new film
}
```
```
public IActionResult Update(Film film) {
    // update the existing film by ID
}
```
We use Film as the type of the parameters, and the model binding engine will handle it without any issue.
